<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>My Project: PRACTICA TEMPLATE</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">PRACTICA TEMPLATE </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro_sec">Introducción</a></li>
<li class="level1"><a href="#platillas">Uso de templates</a></li>
<li class="level1"><a href="#functor">functor</a></li>
<li class="level1"><a href="#generalizar">Generalizando el conjunto.</a><ul><li class="level2"><a href="#insert">Insert</a></li>
<li class="level2"><a href="#SP2">SE PIDE</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><dl class="section version"><dt>Version</dt><dd>v0 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Juan F. Huete</dd></dl>
<h1><a class="anchor" id="intro_sec"></a>
Introducción</h1>
<p>En la práctica anterior se os pidió la implementación del tipo conjunto de crímenes junto con sus iteradores asociados. En esta práctica, el objetivo es seguir avanzando en el uso de las estructuras de datos, particularmente mediante el uso de plantillas (templates) para la definición de tipos de datos genéricos.</p>
<p>Nuestro objetivo es dotar al TDA conjunto de la capacidad de controlar el criterio que se sigue para ubicar los elementos en el mismo. Para ello, es necesario que sobre el tipo de dato que se instancia el conjunto, en nuestro caso crimen se tenga definido una relacion de preorden total, R, esto es:</p>
<ul>
<li>Para todo x,y: xRy || yRx </li>
<li>Para todo x,y,z: Si xRy &amp;&amp; yRz entonces xRz</li>
</ul>
<p>Por tanto R es una relación binaria que toma como entrada dos elementos del mismo tipo y como salida nos devuelve un booleano. Ejemplos de este tipo de relaciones son el operator&lt; (o el operator&gt;) que se pueden definir sobre la clase crimen </p><div class="fragment"><div class="line"><span class="keyword">class </span>crimen {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  crimen();</div>
<div class="line">  ....</div>
<div class="line">  <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> crimen &amp; y);</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  ....</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">bool</span> crimen::operator&lt;(<span class="keyword">const</span> crimen &amp; y){</div>
<div class="line">  <span class="keywordflow">return</span> (this-&gt;ID &lt; y.ID);</div>
<div class="line">}</div>
</div><!-- fragment --><p>El criterio de ordenación será proporcionado a la hora de definir un conjunto, que será gestionado mediante por un objeto de comparación interno (functor de tipo CMP).</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CMP&gt; <span class="keyword">class </span>conjunto;</div>
</div><!-- fragment --><p>La expresion comp(a,b), donde comp es un objeto de la clase CMP devuelve true si se considera que a precede b en la relación de preorden. Esta relación será utilizada por el set tanto para decidir cuando un elemento precede a otro en el contenedor como para determinar cuando dos elementos son equivalentes: para determinar cuando dos elementos serán considerados iguales con respecto a la relacion tendremos en cuenta que </p><ul>
<li>Si (!comp(a,b) &amp;&amp; !comp(b,a)) entonces necesariamente a==b.</li>
</ul>
<h1><a class="anchor" id="platillas"></a>
Uso de templates</h1>
<p>Hasta ahora, los crímenes se encuentran almacenados en orden no decreciente de su valor de ID. Este conjunto puede ser de utilidad en muchos casos, sin embargo nos podríamos plantear el ordenar los elementos dentro del conjunto utilizando cualquier otro criterio. Así, podriamos tener</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;conjunto.h&quot;</span></div>
<div class="line">...</div>
<div class="line"><span class="comment">// declaracion de tipos básicos:</span></div>
<div class="line">conjunto&lt;less&lt;crimen &gt; &gt; X;  <span class="comment">// elementos ordenados en orden creciende  (operator&lt; sobre crimen)</span></div>
<div class="line">conjunto&lt;greater&lt;crimen&gt; &gt; Y; <span class="comment">// elementos ordenados en orden decreciente (operator&gt; sobre crimen)</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// declaracion de tipos más complejos:</span></div>
<div class="line"></div>
<div class="line">conjunto&lt;less&lt;crimen&gt; &gt;::iterator itl;</div>
<div class="line">conjunto&lt;greater&lt;crimen&gt; &gt;::iterator itg;</div>
<div class="line"></div>
<div class="line">conjunto&lt;greater&lt;crimen&gt; &gt; Desc(X.begin(),X.end()); <span class="comment">//los mismos elementos ordenados decrecientemente.</span></div>
<div class="line"></div>
<div class="line">... </div>
<div class="line"></div>
<div class="line"><span class="keywordflow">if</span> (X.find(<span class="stringliteral">&quot;1234&quot;</span>) == X.end()) </div>
<div class="line">   ....</div>
</div><!-- fragment --><p>Hay que notar que en este ejemplo X e Y representan a tipos distintos, esto es un conjunto ordenado en orden creciente de ID NO SERÁ del mismo tipo que un conjunto ordenado en orden decreciente de ID. De igual forma, itl e itg tampoco serán variables del mismo tipo, por lo que no podríamos hacer entre otras cosas asignaciones como X=Y o itg=itl.</p>
<p>En este caso, para realizar la práctica, el alumno deberá modificar tanto el fichero de especificación, conjunto.h, de forma que la propia especificación indique que trabaja con parámetros plantilla, como los ficheros de implementación (.hxx) de la clase conjunto. Además deberá de modificar los ficheros crimen.h y crimen.hxx para permitir la definición dels distintas relaciones de orden.</p>
<p>De igual forma se debe modificar el fichero principal.cpp de manera que se demuestre el correcto comportamiento del diccionario cuando se instancia bajo distintos criterios de ordenación, en concreto debemos asegurarnos que utilizamos los siguientes criterios de ordenación:</p>
<ul>
<li>creciente por id </li>
<li>decreciente por id </li>
<li>creciente por fecha </li>
<li>decreciente por fecha </li>
<li>creciente por IUCR</li>
</ul>
<p>Para los dos primeros casos, y teniendo en cuenta que tenemos sobrecargado los operadores relaciones para crimen, es suficiente con utilizar las clases genéricas less&lt;T&gt; y greater&lt;T&gt; definidas en functional ( #include &lt;functional&gt; ). Sin embargo, para el resto de casos debemos implementar los functores que nos permitan realizar la correcta comparación entre crimenes.</p>
<h1><a class="anchor" id="functor"></a>
functor</h1>
<p>Para realizar dichas comparaciones utilizaremos una herramienta potente de C++: un functor (objeto función). Un functor es una clase en C++ que actua como una función. Un functor puede ser llamado puede ser llamado con una sintaxis familiar a la de las funciones en C++, pudiendo devolver valores y aceptar parámetros como una función normal.</p>
<p>Por ejemplo, si queremos crear un functor que compare dos crímenes teniendo en cuenta el orden IUCR, podríamos hacer</p>
<div class="fragment"><div class="line">crimen x,y;</div>
<div class="line">...</div>
<div class="line">ComparacionPorFecha miFunctor;</div>
<div class="line">cout &lt;&lt; miFunctor(x,y) &lt;&lt; endl;</div>
</div><!-- fragment --><p> Aunque miFunctor es un objeto, en la llamada miFunctor(x,y) la tratamos como si estuviésemos invocando a una función tomando x e y como parámetros.</p>
<p>Para crear dicho functor, creamos un objeto que sobrecarga el operador() como sigue</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>ComparacionPorFecha {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">   <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> crimen &amp;a, <span class="keyword">const</span> crimen &amp;b) {</div>
<div class="line">     <span class="keywordflow">return</span> (a.getDate() &lt; b.getDate()); <span class="comment">// devuelve verdadero si el crimen a precede a b en el tiempo</span></div>
<div class="line"> }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="generalizar"></a>
Generalizando el conjunto.</h1>
<p>Para poder extender nuestro conjunto hemos de dotarlo de la capacidad de poder definir el criterio de ordenación. Para ello vamos a considerar un caso simplificado (que no se corresponde exactamente con lo que se pide en la práctica) donde ilustraremos su uso</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> CMP&gt;</div>
<div class="line"><span class="keyword">class </span>conjunto {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    ....</div>
<div class="line">    <span class="keywordtype">void</span> insert( <span class="keyword">const</span> crimen &amp; c);</div>
<div class="line"></div>
<div class="line">  <span class="keyword">private</span>:</div>
<div class="line">    vector&lt;crimen&gt; vc; <span class="comment">//donde se almacenan los datos</span></div>
<div class="line">    CMP comp;</div>
<div class="line">};</div>
</div><!-- fragment --><p> Como hemos dicho, el nombre del tipo ahora es conjunto&lt;CMP&gt; y no conjunto. Distintas particularizaciones dan lugar a tipos también distintos. Ahora, en el fichero conjunto.hxx debemos de implementar cada uno de los métodos, recordemos que cada uno de ellos pertenece a la clase conjunto&lt;CMP&gt; y por tanto se implementa considerando </p><div class="fragment"><div class="line">valorReturn conjunto&lt;CMP&gt;::nombreMetodo( parametros ...)</div>
</div><!-- fragment --><p>Pasamos a ver la implementación de los métodos:</p>
<h2><a class="anchor" id="insert"></a>
Insert</h2>
<p>El método insert asume como prerequisito que el conjunto está ordenado según el criterio dado por CMP, y por tanto debe asegurar que tras insertar un nuevo crimen dicho conjunto siga ordenado. Por ejemplo, podríamos hacer (recordad que en prácticas se pide hacer la búsqueda binaria) algo del tipo </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> conjunto&lt;CMP&gt;::insert( <span class="keyword">const</span> crimen &amp; s){</div>
<div class="line">        <span class="keywordtype">bool</span> insertado = <span class="keyword">false</span>;</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0; !insertado &amp;&amp; i &lt; v.size(); )</div>
<div class="line">            <span class="keywordflow">if</span> (comp(v[i],s) ) i++;</div>
<div class="line">            <span class="keywordflow">else</span> {</div>
<div class="line">              v.insert(v.begin()+i,s);</div>
<div class="line">              insertado = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">        <span class="keywordflow">if</span> (!insertado) v.push_back(s);</div>
<div class="line">     }</div>
</div><!-- fragment --><p>En este caso comp(v[i],s) hace referencia a una comparación genérica entre crímenes definida por la relación de orden con la que se haya particularizado el conjunto. Así si hemos definido</p>
<div class="fragment"><div class="line">conjunto&lt;ComparacionPorFecha&gt; cf;</div>
</div><!-- fragment --><p>en este caso comp es un objeto de la clase ComparacionPorFecha, y mediante la llamada comp(v[i],s) lo que estamos haciendo es llamar a la "función" que me compara dos crimenes teniendo en cuenta su campo fecha.</p>
<p>Finalmente, debemos tener cuidado a la hora de realizar comparaciones y la semántica de las mismas, por ejemplo, si queremos implementar la búsqueda binaria en un vector&lt;crimen&gt; que está dentro de un conjunto&lt;less&lt;crimen&gt; &gt; podriamos hacer algo como</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> conjunto&lt;CMP&gt;::busquedaBinaria (<span class="keyword">const</span> crimen &amp;d ){</div>
<div class="line">    <span class="keywordtype">int</span> sup=vc.size()-1;</div>
<div class="line">    <span class="keywordtype">int</span> inf = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (sup &gt; inf) {</div>
<div class="line">      medio = (inf+sup)/2;</div>
<div class="line">      <span class="keywordflow">if</span> (vc[medio] == d) <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// comparamos igualdad entre crimen</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (vc[medio] &lt; d) inf = medio+1; <span class="comment">// comparamos menor entre crimen</span></div>
<div class="line">      <span class="keywordflow">else</span> sup = medio-1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p> En este caso, estaríamos haciendo la llamada a la comparación de igualdad y menor entre crímenes (definida medianta la comparación de su ID) por lo que podría funcionar correctamente el método. Sin embargo, si el conjunto está definido como conjunto&lt;ComparacionPorFecha&gt;, utilizar el mismo código para realizar la búsqueda binaria no funcionaria correctamente: los elementos están ordenados en orden creciente de fecha. De hecho, no tendría sentido utilizar la búsqueda binaria para buscar un ID pues los elementos no se encuentran ordenados según ID en este conjunto&lt;CompararPorFecha&gt;.</p>
<p>El siguiente código nos permitiría utilizar la búsqueda binaria utilizando el criterio utilizado para ordenar los elementos en el conjunto. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> conjunto&lt;CMP&gt;::busquedaBinaria (<span class="keyword">const</span> crimen &amp;d ){</div>
<div class="line">    <span class="keywordtype">int</span> sup=vc.size()-1;</div>
<div class="line">    <span class="keywordtype">int</span> inf = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (sup &gt; inf) {</div>
<div class="line">      medio = (inf+sup)/2;</div>
<div class="line">      <span class="keywordflow">if</span> (!comp(vc[medio],d) &amp;&amp; !comp(d,vc[medio]) ) <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// comparamos igualdad entre crimen</span></div>
<div class="line">      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (comp(vc[medio],d)) inf = medio+1; <span class="comment">// comparamos menor entre crimen</span></div>
<div class="line">      <span class="keywordflow">else</span> sup = medio-1;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="SP2"></a>
SE PIDE</h2>
<p>Con la idea de reducir la parte de codificación, sólo será necesario entregar la implementacion del conjunto y dos de sus iteradores (la entrega del resto de ellos es opcional). </p><ul>
<li>conjunto&lt;COMP&gt;::iterator </li>
<li>conjunto&lt;COMP&gt;::const_iterator</li>
</ul>
<p>Además, al TDA conjunto le incluiremos los siguientes métodos: </p><ul>
<li>conjunto&lt;CMP&gt;::conjunto(iterator ini, iterator fin); Constructor de conjunto que contiene los elementos contenidos en el rango [ini,fin) </li>
<li>iterator conjunto&lt;CMP&gt;::find(const crimen &amp; c); </li>
<li>const_iterator conjunto&lt;CMP&gt;::find(const crimen &amp; c)const; Hace la búsqueda binaria del elemento en el conjunto considerando el orden definido por CMP. Devuelve el iterador que apunta a la posición donde se encuetra el elemento o end() en caso contrario. </li>
<li>iterator conjunto&lt;CMP&gt;::find(const long int &amp; id); </li>
<li>const_iterator conjunto&lt;CMP&gt;::find(const long int &amp; id)const; En este caso, como no sabemos cómo están ordenados los elementos será necesario realizar una una búsqueda lineal. </li>
<li>iterator lower_bound (const entrada &amp; x); </li>
<li>const_iterator lower_bound (const entrada &amp; x) const; Devuelven un iterador al primer elemento en el contenedor que no precede a x en el conjunto, esto es, es equivalente a x o le sigue según la relacion de orden definida por CMP. Esta función utiliza el functor interno devolviendo un iterador al primer elemento, e, para el que se satisface que comp(e,x) es falso. </li>
<li>iterator upper_bound (const entrada &amp; x); </li>
<li>const_iterator lower_bound (const entrada &amp; x) const; Devuelven un iterador al primer elemento que sigue a x según la relacion de orden definida por CMP. Esta función utiliza el functor interno devolviendo un iterador al primer elemento, e, para el que se satisface que comp(x,e) es cierto.</li>
</ul>
<p>Dicha entrega se debe realizar antes del Viernes 27 de Noviembre, a las 23:59 horas. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
